When you are using Git, you will frequently want to check the status of your repository. To do this, run the command git status, which displays a list of the files that have been modified since the last time changes were saved.

cd repository
git status


Git has a staging area in which it stores files with changes you want to save that haven't been saved yet. 
Putting files in the staging area is like putting things in a box, while committing those changes is like putting that box in the mail (which is the .git directory, the permanent storage): 
you can add more things to the box or take things out as often as you want, but once you put it in the mail, you can't make further changes.

git diff
git diff filename 
git diff directory





You commit changes to a Git repository in two steps:
1.Add one or more files to the staging area.
2.Commit everything in the staging area.
To add a file to the staging area, use 

git add filename


To compare a file's current state to the changes in the staging area, you can use:
git diff -r HEAD path/to/file

-r: "compare to a particular revision", 
HEAD: a shortcut meaning "the most recent commit"


git commit
It always saves everything that is in the staging area as one unit: as you will see later, when you want to undo changes to a project, you undo all of a commit or none of it.
When you commit changes, Git requires you to enter a log message.
-m "" stands for the message
git commit -m "Program appears to have become self-aware."


git log: to view the log of the project's history.









In order to make common operations fast and minimize storage space, Git uses a multi-level structure to store data. In simplified form, this has three key parts:
Every unique version of every file. (Git calls these blobs because they can contain data of any kind.)
tree that tracks the names and locations of a set of files.
A commit that records the author, log message, and other properties of a particular commit.


What is a hash?
Every commit to a repository has a unique identifier called a hash 
(since it is generated by running the changes through a pseudo-random number generator called a hash function). 
This hash is normally written as a 40-character hexadecimal string like 7c35a3ce607a14953f070f0f83b5d74c2296ef93, 
but most of the time, you only have to give Git the first 6 or 8 characters in order to identify the commit you mean.
Hashes are what enable Git to share data efficiently between repositories. 
If two files are the same, their hashes are guaranteed to be the same. 
Similarly, if two commits contain the same files and have the same ancestors, their hashes will be the same as well. 
Git can therefore tell what information needs to be saved where by comparing hashes rather than comparing entire files.


Info about a commit:
git show first_six_digits_of_hash


We can refer to the most recent commit (end of git log) by HEAD
HEAD~1: commit before the most recent
HEAD~2
...

git show HEAD~1


#Check who has changed the file:
git annotate filename

#Show the difference between two commits
git diff HEAD~1..HEAD~3


Data analysis often produces temporary or intermediate files that you don't want to save. 
You can tell it to stop paying attention to files you don't care about by creating a file in the root directory of your repository called .gitignore 
and storing a list of wildcard patterns that specify the files you don't want Git to pay attention to.


Git can help you clean up files that you have told it you don't want. 
The command 
git clean -n 
will show you a list of files that are in the repository, but whose history Git is not currently tracking. 
A similar command 
git clean -f 
will then delete those files.
Use this command carefully: git clean only works on untracked files, so by definition, their history has not been saved. If you delete them with git clean -f, they're gone for good.



#Check Git settings:
git config --list
--system: settings for every user on this computer.
--global: settings for every one of your projects.
--local: settings for one specific project.


To change a configuration value for all of your projects on a particular computer, run the command:
git config --global setting.name setting.value
ser.name,user.email


#Undo changes, which has not yet been staged:
git checkout -- filename

#Or undo everything
git checkout -- . 


#Undo changes which has already been staged:
git reset HEAD filename

#Restore report.txt to the stage of the commit hash
git checkout 2242bd report.txt












One of the reasons Git is popular is its support for creating branches. 
A branch is like a parallel universe: changes you make in one branch do not affect other branches until you merge them back together. 
It's like creating sub-directories called final, final-updated, final-updated-revised, and so on, but with support for tracking work systematically.


#List branches
git branch

#Difference between 2 branches
git diff branch-1..branch-2


When you run git branch, it puts a * beside the name of the branch you are currently in. To switch to another branch, you use 
git checkout branch-name


